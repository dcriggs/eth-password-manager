{
  "language": "Solidity",
  "sources": {
    "contracts/ShareablePasswordManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\nimport \"./UserPasswordManager.sol\";\r\n\r\ncontract ShareablePasswordManager is UserPasswordManager {\r\n\tstruct SharedPasswordData {\r\n\t\tstring name;\r\n\t\tstring encryptedDataHash;\r\n\t\taddress sharedBy;\r\n\t\taddress sharedWith;\r\n\t}\r\n\r\n\t// Mappings to store shared passwords for each user\r\n\tmapping(address => address[]) private recipients;\r\n\tmapping(address => address[]) private senders;\r\n\tmapping(address => uint256) private sentPasswordCount;\r\n\tmapping(address => uint256) private receivedPasswordCount;\r\n\r\n\t// Mapping to track which passwords a user has shared with others\r\n\tmapping(address => mapping(address => SharedPasswordData[]))\r\n\t\tprivate sharedPasswords;\r\n\r\n\t// Event emitted when a password is shared\r\n\tevent PasswordShared(address indexed sender, address indexed recipient);\r\n\r\n\t// Event emitted when a shared password is revoked\r\n\tevent SharedPasswordRevoked(\r\n\t\taddress indexed sender,\r\n\t\taddress indexed recipient\r\n\t);\r\n\r\n\tconstructor(address _owner) UserPasswordManager(_owner) {}\r\n\r\n\t// Function to share a password with another registered user\r\n\tfunction sharePassword(\r\n\t\taddress recipient,\r\n\t\tstring memory name,\r\n\t\tstring memory encryptedDataHash\r\n\t) external onlyRegistered {\r\n\t\t// Ensure the recipient is a registered user\r\n\t\trequire(isUserRegistered(recipient), \"Recipient is not registered.\");\r\n\t\trequire(recipient != msg.sender, \"Cannot share with same address.\");\r\n\r\n\t\t// Create the SharedPasswordData struct and add it to the recipient's shared passwords\r\n\t\tSharedPasswordData memory newPassword = SharedPasswordData(\r\n\t\t\tname,\r\n\t\t\tencryptedDataHash,\r\n\t\t\tmsg.sender,\r\n\t\t\trecipient\r\n\t\t);\r\n\t\tsharedPasswords[msg.sender][recipient].push(newPassword);\r\n\r\n\t\tsentPasswordCount[msg.sender]++;\r\n\t\treceivedPasswordCount[recipient]++;\r\n\r\n\t\t// Check if the sender is already in the recipient's senders list\r\n\t\tbool senderExists = false;\r\n\t\tfor (uint256 i = 0; i < senders[recipient].length; i++) {\r\n\t\t\tif (senders[recipient][i] == msg.sender) {\r\n\t\t\t\tsenderExists = true;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (!senderExists) {\r\n\t\t\tsenders[recipient].push(msg.sender);\r\n\t\t}\r\n\r\n\t\t// Check if the recipient is already in the sender's recipients list\r\n\t\tbool recipientExists = false;\r\n\t\tfor (uint256 i = 0; i < recipients[msg.sender].length; i++) {\r\n\t\t\tif (recipients[msg.sender][i] == recipient) {\r\n\t\t\t\trecipientExists = true;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (!recipientExists) {\r\n\t\t\trecipients[msg.sender].push(recipient);\r\n\t\t}\r\n\r\n\t\t// Emit the event\r\n\t\temit PasswordShared(msg.sender, recipient);\r\n\t}\r\n\r\n\t// Function to revoke a shared password\r\n\tfunction revokeSharedPassword(\r\n\t\taddress recipient,\r\n\t\tstring memory name,\r\n\t\tstring memory encryptedDataHash\r\n\t) external onlyRegistered {\r\n\t\t// Find the password and remove it from the recipient's shared passwords\r\n\t\tSharedPasswordData[] storage recipientPasswords = sharedPasswords[\r\n\t\t\tmsg.sender\r\n\t\t][recipient];\r\n\t\tbool anyRemoved;\r\n\t\tfor (uint256 i = 0; i < recipientPasswords.length; i++) {\r\n\t\t\tif (\r\n\t\t\t\tkeccak256(abi.encodePacked(recipientPasswords[i].name)) ==\r\n\t\t\t\tkeccak256(abi.encodePacked(name)) &&\r\n\t\t\t\tkeccak256(\r\n\t\t\t\t\tabi.encodePacked(recipientPasswords[i].encryptedDataHash)\r\n\t\t\t\t) ==\r\n\t\t\t\tkeccak256(abi.encodePacked(encryptedDataHash))\r\n\t\t\t) {\r\n\t\t\t\t// Remove the password by swapping it with the last element and then popping it\r\n\t\t\t\trecipientPasswords[i] = recipientPasswords[\r\n\t\t\t\t\trecipientPasswords.length - 1\r\n\t\t\t\t];\r\n\t\t\t\trecipientPasswords.pop();\r\n\t\t\t\tsentPasswordCount[msg.sender]--;\r\n\t\t\t\treceivedPasswordCount[recipient]--;\r\n\r\n\t\t\t\t// If no passwords are left, update the senders and recipients mappings\r\n\t\t\t\tif (recipientPasswords.length == 0) {\r\n\t\t\t\t\t// Remove sender from recipient's senders list\r\n\t\t\t\t\tremoveAddressFromList(senders[recipient], msg.sender);\r\n\t\t\t\t\t// Remove recipient from sender's recipients list\r\n\t\t\t\t\tremoveAddressFromList(recipients[msg.sender], recipient);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tanyRemoved = true;\r\n\r\n\t\t\t\t// Emit the event\r\n\t\t\t\temit SharedPasswordRevoked(msg.sender, recipient);\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (!anyRemoved) revert(\"No matching password found.\");\r\n\t}\r\n\r\n\t// Helper function to remove an address from an array\r\n\tfunction removeAddressFromList(\r\n\t\taddress[] storage list,\r\n\t\taddress addrToRemove\r\n\t) internal {\r\n\t\tfor (uint256 i = 0; i < list.length; i++) {\r\n\t\t\tif (list[i] == addrToRemove) {\r\n\t\t\t\tlist[i] = list[list.length - 1];\r\n\t\t\t\tlist.pop();\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t// Function to retrieve shared passwords that have been sent to a user\r\n\tfunction getSharedPasswordsSent(\r\n\t\taddress recipient\r\n\t) external view onlyRegistered returns (SharedPasswordData[] memory) {\r\n\t\treturn sharedPasswords[msg.sender][recipient];\r\n\t}\r\n\r\n\t// Function to retrieve shared passwords that have been received from a user\r\n\tfunction getSharedPasswordsReceived(\r\n\t\taddress sender\r\n\t) external view onlyRegistered returns (SharedPasswordData[] memory) {\r\n\t\treturn sharedPasswords[sender][msg.sender];\r\n\t}\r\n\r\n\t// Function to retrieve all shared passwords sent by the caller\r\n\tfunction getAllSharedPasswordsSent()\r\n\t\texternal\r\n\t\tview\r\n\t\tonlyRegistered\r\n\t\treturns (SharedPasswordData[] memory)\r\n\t{\r\n\t\t// Determine the total number of passwords sent\r\n\t\tuint256 totalSentPasswords = sentPasswordCount[msg.sender];\r\n\r\n\t\t// Create an array to store the sent passwords\r\n\t\tSharedPasswordData[] memory allSentPasswords = new SharedPasswordData[](\r\n\t\t\ttotalSentPasswords\r\n\t\t);\r\n\r\n\t\tuint256 index = 0;\r\n\t\taddress[] memory recipientsList = recipients[msg.sender];\r\n\r\n\t\tfor (uint256 i = 0; i < recipientsList.length; i++) {\r\n\t\t\taddress recipient = recipientsList[i];\r\n\t\t\tSharedPasswordData[] memory sentPasswords = sharedPasswords[\r\n\t\t\t\tmsg.sender\r\n\t\t\t][recipient];\r\n\r\n\t\t\tfor (uint256 j = 0; j < sentPasswords.length; j++) {\r\n\t\t\t\tallSentPasswords[index] = sentPasswords[j];\r\n\t\t\t\tindex++;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn allSentPasswords;\r\n\t}\r\n\r\n\t// Function to retrieve all shared passwords received by the caller\r\n\tfunction getAllSharedPasswordsReceived()\r\n\t\texternal\r\n\t\tview\r\n\t\tonlyRegistered\r\n\t\treturns (SharedPasswordData[] memory)\r\n\t{\r\n\t\t// Determine the total number of passwords received\r\n\t\tuint256 totalReceivedPasswords = receivedPasswordCount[msg.sender];\r\n\r\n\t\t// Create an array to store the received passwords\r\n\t\tSharedPasswordData[]\r\n\t\t\tmemory allReceivedPasswords = new SharedPasswordData[](\r\n\t\t\t\ttotalReceivedPasswords\r\n\t\t\t);\r\n\r\n\t\tuint256 index = 0;\r\n\t\taddress[] memory sendersList = senders[msg.sender];\r\n\r\n\t\tfor (uint256 i = 0; i < sendersList.length; i++) {\r\n\t\t\taddress sender = sendersList[i];\r\n\t\t\tSharedPasswordData[] memory receivedPasswords = sharedPasswords[\r\n\t\t\t\tsender\r\n\t\t\t][msg.sender];\r\n\r\n\t\t\tfor (uint256 j = 0; j < receivedPasswords.length; j++) {\r\n\t\t\t\tallReceivedPasswords[index] = receivedPasswords[j];\r\n\t\t\t\tindex++;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn allReceivedPasswords;\r\n\t}\r\n}\r\n"
    },
    "contracts/UserPasswordManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\ncontract UserPasswordManager {\r\n\taddress public owner;\r\n\r\n\tstruct PasswordData {\r\n\t\tstring name;\r\n\t\tstring encryptedDataHash;\r\n\t}\r\n\r\n\tmapping(address => bool) internal isRegistered;\r\n\tmapping(address => string) internal userPublicKeys;\r\n\tmapping(address => PasswordData[]) internal userPasswords;\r\n\r\n\tevent UserRegistered(address indexed user);\r\n\tevent PasswordStored(address indexed user);\r\n\tevent PasswordDetailsUpdated(address indexed user);\r\n\tevent PasswordDeleted(address indexed user);\r\n\r\n\tconstructor(address _owner) {\r\n\t\towner = _owner == address(0) ? msg.sender : _owner; // Default to deployer if _owner is address(0)\r\n\t}\r\n\r\n\tmodifier onlyOwner() {\r\n\t\trequire(msg.sender == owner, \"Not the contract owner.\");\r\n\t\t_;\r\n\t}\r\n\r\n\tmodifier onlyRegistered() {\r\n\t\trequire(isRegistered[msg.sender], \"User is not registered.\");\r\n\t\t_;\r\n\t}\r\n\r\n\tfunction isUserRegistered(address user) public view returns (bool) {\r\n\t\treturn isRegistered[user];\r\n\t}\r\n\r\n\t// Virtual function to allow overriding in child contracts\r\n\tfunction registerUser(string memory publicKey) external payable virtual {\r\n\t\trequire(!isRegistered[msg.sender], \"User already registered.\");\r\n\t\trequire(\r\n\t\t\tmsg.value >= 0.01 ether,\r\n\t\t\t\"Insufficient registration fee. At least 0.01 ETH required.\"\r\n\t\t);\r\n\r\n\t\t// Call the original registerUser logic from the parent contract\r\n\t\tisRegistered[msg.sender] = true;\r\n\t\tuserPublicKeys[msg.sender] = publicKey;\r\n\r\n\t\temit UserRegistered(msg.sender);\r\n\t}\r\n\r\n\tfunction storePassword(\r\n\t\tstring memory name,\r\n\t\tstring memory encryptedDataHash\r\n\t) external onlyRegistered {\r\n\t\tPasswordData memory newPasswordData = PasswordData({\r\n\t\t\tname: name,\r\n\t\t\tencryptedDataHash: encryptedDataHash\r\n\t\t});\r\n\r\n\t\tuserPasswords[msg.sender].push(newPasswordData);\r\n\r\n\t\temit PasswordStored(msg.sender);\r\n\t}\r\n\r\n\tfunction updatePasswordDetails(\r\n\t\tuint index,\r\n\t\tstring memory name,\r\n\t\tstring memory encryptedDataHash\r\n\t) external onlyRegistered {\r\n\t\trequire(index < userPasswords[msg.sender].length, \"Invalid index.\");\r\n\r\n\t\tPasswordData storage passwordData = userPasswords[msg.sender][index];\r\n\t\tpasswordData.name = name;\r\n\t\tpasswordData.encryptedDataHash = encryptedDataHash;\r\n\r\n\t\temit PasswordDetailsUpdated(msg.sender);\r\n\t}\r\n\r\n\tfunction deletePassword(uint index) external onlyRegistered {\r\n\t\trequire(index < userPasswords[msg.sender].length, \"Invalid index.\");\r\n\r\n\t\t// Move the last element into the place to delete\r\n\t\tuserPasswords[msg.sender][index] = userPasswords[msg.sender][\r\n\t\t\tuserPasswords[msg.sender].length - 1\r\n\t\t];\r\n\t\tuserPasswords[msg.sender].pop();\r\n\r\n\t\temit PasswordDeleted(msg.sender);\r\n\t}\r\n\r\n\tfunction getPasswords()\r\n\t\texternal\r\n\t\tview\r\n\t\tonlyRegistered\r\n\t\treturns (PasswordData[] memory)\r\n\t{\r\n\t\treturn userPasswords[msg.sender];\r\n\t}\r\n\r\n\tfunction getUserPublicKey(\r\n\t\taddress user\r\n\t) external view onlyRegistered returns (string memory) {\r\n\t\treturn userPublicKeys[user];\r\n\t}\r\n\r\n\tfunction withdraw() external onlyOwner {\r\n\t\trequire(\r\n\t\t\taddress(this).balance > 0,\r\n\t\t\t\"No funds available for withdrawal.\"\r\n\t\t);\r\n\r\n\t\t(bool success, ) = owner.call{ value: address(this).balance }(\"\");\r\n\t\trequire(success, \"Withdrawal failed.\");\r\n\t}\r\n}\r\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}